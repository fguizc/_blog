<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="fguizc"><title>JS发布——订阅模式 · Fguizc</title><meta name="description" content="发布——订阅模式
全文为阅读《Javascript设计模式与开发实践》一书读书笔记。该篇，发布——订阅模式，在使用前端框架时这种设计理念被大量运用。

发布—订阅模式又叫观察者模式，它定义对象间的一种一对多的依赖关系，当一个对象的状 态发生改变时，所有依赖于它的对象都将得到通知。在 JavaScri"><meta name="keywords"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><h3 title=""><a href="/">Fguizc</a></h3></div></div><ul class="social-links"><li><a href="http://instagram.com/zcsdt" target="blank"><i class="fa fa-instagram"></i></a></li><li><a href="http://github.com/fguizc" target="blank"><i class="fa fa-github"></i></a></li><li><a href="https://git.oschina.net/fguizc" target="blank"><i class="fa fa-code"></i></a></li><li><a href="http://steamcommunity.com/profiles/76561198255058450" target="blank"><i class="fa fa-steam"></i></a></li></ul><div class="blog-desc">时间胶囊</div><div class="footer"><a target="_blank" href="/"><span>Theme by </span></a><a href="https://www.caicai.me"> CaiCai </a><span>&</span><a href="https://github.com/Ben02/hexo-theme-Anatole"> Ben</a><div class="by_farbox"><a href="https://hexo.io/zh-cn/" target="_blank">Proudly published with Hexo&#65281;</a></div></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">首页</a></li><li><a href="/about">关于</a></li><li><a href="/archives">归档</a></li></div><div class="information"><div class="back_btn"><li><a onclick="window.history.go(-1)" class="fa fa-chevron-left"> </a></li></div><div class="avatar"><img src="http://7xv7pp.com1.z0.glb.clouddn.com/avatar_new.jpg"></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>JS发布——订阅模式</a></h3></div><div class="post-content"><h2>发布——订阅模式</h2>
<p>全文为阅读《Javascript设计模式与开发实践》一书读书笔记。该篇，发布——订阅模式，在使用前端框架时这种设计理念被大量运用。</p>
<blockquote>
<p>发布—订阅模式又叫观察者模式，它定义对象间的一种一对多的依赖关系，当一个对象的状 态发生改变时，所有依赖于它的对象都将得到通知。在 JavaScript 开发中，我们一般用事件模型 来替代传统的发布—订阅模式。</p>
</blockquote>
<p>发布——订阅模式常应用于异步编程，这是一种代替传递回调函数的方案。例如订阅 ajax 请求的 error、succ 事件（突然想到axios 拦截器功能），总之是用发布——订阅模式可以无需关注异步过程内部状态，只需要订阅特定情况的发生。另外一点，发布——订阅模式不再显示由一个对象调用另一个对象的接口，降低耦合，互不影响，当新增订阅者出现，既不会影响之前订阅者，也不会需要对发布者修改，同样，发布者需要修改时，也不会影响到之前订阅者（前提是两者约定事件名称没有改变）。</p>
<h3>DOM 事件</h3>
<p>在接触 JS 的时候会学习到 <code>addEventListener</code> ，绑定事件函数，比起如 <code>onClick</code> 这样的直接绑定，<code>addEventListener</code> 不会覆盖之前绑定事件，实际上它就是一个简单的发布——订阅模式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">document.querySelector(&apos;.btn-submit&apos;).addEventListener(&apos;click&apos;, function () &#123;</span><br><span class="line">	console.log(&apos;something&apos;);</span><br><span class="line">&#125;, false);</span><br><span class="line"></span><br><span class="line">document.querySelector(&apos;.btn-submit&apos;).click()</span><br></pre></td></tr></table></figure>
<p>这里监听了用户点击事件行为，当点击特定的按钮就会触发相应事件，但重要的是无法预知用户何时点击。所以订阅 <code>.btn-submit</code> 这个按钮的 <code>click</code> 事件。当其被点击，便会向订阅者发布消息。</p>
<h3>自定义事件</h3>
<p>除去常见 DOM 事件，还会需求实现一些自定义事件，这种依靠自定义事件完成的发布——订阅模式适用性广，无侵入性。
如何一步步实现发布——订阅模式？</p>
<ol>
<li>指定发布者</li>
<li>为发布者添加缓存列表，用于存储回调函数以便通知订阅者（函数存放在缓存列表中表明同一事件可以依次触发多个回调函数）</li>
<li>发布消息，发布者遍历缓存列表，依次触发其中存放订阅者回调函数。</li>
</ol>
<p>值得一提，为增强功能丰富语义，回调函数可以填入一些参数，订阅者接收这些参数，订阅者接收到后可以进一步处理。</p>
<p>书中以售楼处为例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"> let salesOffices = &#123;&#125;;</span><br><span class="line"> salesOffices.clientList = [];</span><br><span class="line"> salesOffices.listen = function (fn) &#123;</span><br><span class="line">   this.clientList.push(fn);</span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line"> salesOffices.trigger = function (...arg) &#123;</span><br><span class="line">   this.clientList.forEach((fn) =&gt; &#123;</span><br><span class="line">  fn(...arg);</span><br><span class="line">&#125;)</span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line"> salesOffices.listen( function( price, squareMeter )&#123; // 小明订阅消息</span><br><span class="line">   console.log( &apos;价格= &apos;  +  price );</span><br><span class="line">   console.log( &apos;squareMeter= &apos;  +  squareMeter );</span><br><span class="line"> &#125;);</span><br><span class="line"></span><br><span class="line"> salesOffices.listen( function( price, squareMeter )&#123; // 小红订阅消息</span><br><span class="line">console.log( &apos;价格= &apos;  +  price );</span><br><span class="line">console.log( &apos;squareMeter= &apos;  +  squareMeter );</span><br><span class="line"> &#125;);</span><br><span class="line"></span><br><span class="line"> salesOffices.trigger( 2000000, 88 ); // 输出两次，因为存在两个订阅者，输出：200 万，88 平方米</span><br><span class="line"></span><br><span class="line"> salesOffices.trigger( 3000000, 110 ); // 输出两次，输出：300 万，110 平方米</span><br></pre></td></tr></table></figure>
<p>书中例子实现一个最简单发布——订阅模式，明显看得出不足，没有针对性，一旦事件发布无论订阅者是否愿意必须接收，最简单改善方法就是给定标识，增加一个标识key来区分订阅者的“兴趣”。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">var salesOffices = &#123;&#125;; // 定义售楼处</span><br><span class="line"></span><br><span class="line">salesOffices.clientList = &#123;&#125;; // 缓存列表，存放订阅者的回调函数，注意，此处缓存列表从数组变为对象</span><br><span class="line"></span><br><span class="line">salesOffices.listen = function( key, fn )&#123;</span><br><span class="line"></span><br><span class="line">  if ( !this.clientList[ key ] )&#123; // 如果还没有订阅过此类消息，给该类消息创建一个缓存列表</span><br><span class="line">    this.clientList[ key ] = [];</span><br><span class="line">  &#125;</span><br><span class="line">  this.clientList[ key ].push( fn ); // 订阅的消息添加进消息缓存列表</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">salesOffices.trigger  =  function()&#123; // 发布消息</span><br><span class="line"></span><br><span class="line">  var  key  =  Array.prototype.shift.call(arguments), // 取出消息类型</span><br><span class="line"></span><br><span class="line">  fns  =  this.clientList[key]; // 取出该消息对应的回调函数集合</span><br><span class="line"></span><br><span class="line">  if (!fns  ||  fns.length  ===  0) &#123; // 如果没有订阅该消息，则返回</span><br><span class="line">    return  false;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  for (var  i  =  0, fn; fn  =  fns[i++];) &#123;</span><br><span class="line">    fn.apply(this, arguments); // (2) // arguments 是发布消息时附送的参数</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">salesOffices.listen(&apos;squareMeter88&apos;, function (price) &#123; // 小明订阅 88 平方米房子的消息</span><br><span class="line"></span><br><span class="line">  console.log(&apos;价格= &apos;  +  price); // 输出： 2000000</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">salesOffices.listen(&apos;squareMeter110&apos;, function (price) &#123; // 小红订阅 110 平方米房子的消息</span><br><span class="line"></span><br><span class="line">  console.log(&apos;价格= &apos;  +  price); // 输出： 3000000</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">salesOffices.trigger(&apos;squareMeter88&apos;, 2000000); // 发布 88 平方米房子的价格</span><br><span class="line"></span><br><span class="line">salesOffices.trigger(&apos;squareMeter110&apos;, 3000000); // 发布 110 平方米房子的价格</span><br></pre></td></tr></table></figure>
<p>改造后的代码与第一次相差不多，唯一增加判断订阅者感兴趣的“key”值，在发布者缓存列表中找到对应key值的value（value 是数组，数组每一项均是一个可执行的函数，严谨来说，应该在发布者 <code>listen</code> 方法中去判断传入参数是否为函数）</p>
<h3>通用模式</h3>
<p>以上基本实现最基本发布——订阅模式，此刻又出现新问题也是最常谈及——代码复用，书上的售楼处实现了模式，但当出现新“售楼处”该如何解决，书中解决的办法非常简单，浅克隆。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">var  event  = &#123;</span><br><span class="line"></span><br><span class="line">clientList: [],</span><br><span class="line"></span><br><span class="line">	listen:  function (key, fn) &#123;</span><br><span class="line">	</span><br><span class="line">		if (!this.clientList[key]) &#123;</span><br><span class="line">		</span><br><span class="line">		  this.clientList[key] = [];</span><br><span class="line">		</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		this.clientList[key].push(fn); // 订阅的消息添加进缓存列表</span><br><span class="line">	</span><br><span class="line">	&#125;,</span><br><span class="line"></span><br><span class="line">	trigger:  function () &#123;</span><br><span class="line">	</span><br><span class="line">		var  key  =  Array.prototype.shift.call(arguments), // (1);</span><br><span class="line">		</span><br><span class="line">		fns  =  this.clientList[key];</span><br><span class="line">		</span><br><span class="line">		if (!fns  ||  fns.length  ===  0) &#123; // 如果没有绑定对应的消息</span><br><span class="line">		</span><br><span class="line">			return  false;</span><br><span class="line">	</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		for (var  i  =  0, fn; fn  =  fns[i++];) &#123;</span><br><span class="line">		</span><br><span class="line">		fn.apply(this, arguments); // (2) // arguments 是 trigger 时带上的参数</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 再定义一个 installEvent 函数，这个函数可以给所有的对象都动态安装发布—订阅功能</span><br><span class="line">var installEvent = function( obj )&#123; </span><br><span class="line">	for ( var i in event )&#123; </span><br><span class="line">		obj[ i ] = event[ i ]; </span><br><span class="line">	&#125; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var  salesOffices  = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">installEvent( salesOffices );</span><br><span class="line"></span><br><span class="line">salesOffices.listen( &apos;squareMeter88&apos;, function( price )&#123; // 小明订阅消息</span><br><span class="line"></span><br><span class="line">	console.log( &apos;价格= &apos;  +  price );</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">salesOffices.listen( &apos;squareMeter100&apos;, function( price )&#123; // 小红订阅消息</span><br><span class="line"></span><br><span class="line">	console.log( &apos;价格= &apos;  +  price );</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">salesOffices.trigger( &apos;squareMeter88&apos;, 2000000 ); // 输出：2000000</span><br><span class="line"></span><br><span class="line">salesOffices.trigger( &apos;squareMeter100&apos;, 3000000 ); // 输出：3000000</span><br></pre></td></tr></table></figure>
<h3>取消订阅</h3>
<p>实现完简单的代码复用后，又抛出另一个问题——如何取消事件订阅，思路大概概括：</p>
<ol>
<li>清空发布者缓存列表中对应事件
1.1 若事件未被订阅直接返回false
1.2 删除对应订阅者传入的回调函数</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">event.remove  =  function (key, fn) &#123;</span><br><span class="line"></span><br><span class="line">	var  fns  =  this.clientList[key];</span><br><span class="line">	</span><br><span class="line">	if (!fns) &#123; // 如果 key 对应的消息没有被人订阅，则直接返回</span><br><span class="line">		</span><br><span class="line">		return  false;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">		</span><br><span class="line">	if (!fn) &#123; // 如果没有传入具体的回调函数，表示需要取消 key 对应消息的所有订阅</span><br><span class="line">		</span><br><span class="line">		fns  &amp;&amp; (fns.length  =  0);</span><br><span class="line">		</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		</span><br><span class="line">		for (var  l  =  fns.length  -  1; l  &gt;=  0; l--) &#123; // 反向遍历订阅的回调函数列表</span><br><span class="line">			</span><br><span class="line">			var  _fn  =  fns[l];</span><br><span class="line">			</span><br><span class="line">			if (_fn  ===  fn) &#123;</span><br><span class="line">			</span><br><span class="line">				fns.splice(l, 1); // 删除订阅者的回调函数</span><br><span class="line">			</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var  salesOffices  = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">var  installEvent  =  function (obj) &#123;</span><br><span class="line"></span><br><span class="line">	for (var  i  in  event) &#123;</span><br><span class="line">	</span><br><span class="line">		obj[i] =  event[i];</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">installEvent(salesOffices);</span><br><span class="line"></span><br><span class="line">salesOffices.listen(&apos;squareMeter88&apos;, fn1  =  function (price) &#123; // 小明订阅消息</span><br><span class="line"></span><br><span class="line">	console.log(&apos;价格= &apos;  +  price);</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">salesOffices.listen(&apos;squareMeter88&apos;, fn2  =  function (price) &#123; // 小红订阅消息</span><br><span class="line"></span><br><span class="line">	console.log(&apos;价格= &apos;  +  price);</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">salesOffices.remove(&apos;squareMeter88&apos;, fn1); // 删除小明的订阅</span><br><span class="line"></span><br><span class="line">salesOffices.trigger(&apos;squareMeter88&apos;, 2000000); // 输出：2000000</span><br></pre></td></tr></table></figure>
<h2>实例——登录</h2>
<p>书中举出在实际项目中，用户登录完成后，用户信息可能需要派发到多个模块，诸如header，购物车等，如果使用过 <code>redux</code> 这一类数据管理库不能更容易，如果不使用框架如何解决？</p>
<p>首先最粗暴的做法是在ajax请求成功回调里写入每个需要通知模块的接收事件方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">login.succ(function(data) &#123;</span><br><span class="line">	header.setAvatar(data.avatar); //设置header头像</span><br><span class="line">	nav.setAvatar(data.avatar);    //设置导航模块头像</span><br><span class="line">	message.refresh();			   //刷新信息列表</span><br><span class="line">	cart.refresh();				   //刷新购物车列表</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>试想这样做虽然能解决问题，但当新的功能模块上线时并且也需要用户登录相关信息时，就不得不折回修改 <code>login.succ</code> 函数，为它回调函数内增添新的模块对应接收信息的方法。虽然良好命名规则可以解决一部分代码维护问题，但如果模块接收用户登录信息的方法名更改后，就得疲于应付更改多处，这时改错名或漏掉情况就会出现，所以为什么不偷偷懒？啊！偷懒才是生产力进步的钥匙。</p>
<p>按照发布——订阅模式来改善一下代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">login.succ(function(data) &#123;</span><br><span class="line">	login.trigger(&apos;loginSucc&apos;, data)</span><br><span class="line">&#125;;  // 当登录成功后仅仅发布这一事件，并将服务器返回数据当做参数传入</span><br></pre></td></tr></table></figure>
<p>而其他模块只需要像所有订阅者一样，订阅这个事件就行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const header = (function()&#123;</span><br><span class="line">	login.listen(&apos;loginSucc&apos;, (data) =&gt; &#123;</span><br><span class="line">		header.setAvatar(data.avatar)</span><br><span class="line">	&#125;);</span><br><span class="line">	return &#123;</span><br><span class="line">		setAvatar (avatar) &#123;</span><br><span class="line">			console.log(&apos;为顶部栏设置用户头像&apos;)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; // 此处需显示地返回在上方传入的回调函数</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>
<p>这样一来就解耦登录模块和其他需要登录信息的模块，模块内部维护一个方法当然是更安全省心</p>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2017-09-25</span><i class="fa fa-tag"></i><a href="/tags/js/" title="js" class="tag">js </a><a href="/tags/设计模式/" title="设计模式" class="tag">设计模式 </a></div></div></div></div><div class="share"><div class="evernote"><a href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank" class="fa fa-bookmark"></a></div><div class="weibo"><a href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));" class="fa fa-weibo"></a></div><div class="twitter"><a href="http://twitter.com/home?status=,https://fguizc.xyz/2017/09/25/发布订阅模式——JS设计模式阅读笔记/,Fguizc,JS发布——订阅模式,;" class="fa fa-twitter"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a role="navigation" href="/2017/10/05/async&amp;defer/" title="async&amp;defer" class="btn">上一篇</a></li><li class="next pagbuttons"><a role="navigation" href="/2017/09/19/前端性能优化方法/" title="前端性能优化常见方式" class="btn">下一篇</a></li></ul></div></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script></body></html>